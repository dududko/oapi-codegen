//go:embed {{ .FileBase }}
var spec []byte

// returns a raw spec
func RawSpec() []byte {
    return spec
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathPrefix string) map[string]func() []byte {
    // todo: fix spec validator so that external references are correct;
    // now they can point to api.yaml files whereas the real file name is different
    var res = map[string]func() []byte{
        path.Join(pathPrefix, "{{ .FileBase }}"): RawSpec,
        {{- if (ne .FileBase "api.yaml") }}
        path.Join(pathPrefix, "api.yaml"): RawSpec,
        {{- end }}
    }
    {{ range $key, $value := .ImportMapping }}
    for rawPath, rawFunc := range {{ $value.Name }}.PathToRawSpec(path.Join(pathPrefix, "{{ $value.Path }}")) {
        if _, ok := res[rawPath]; ok {
            panic(fmt.Sprintf("path already exists: %s", rawPath))
        }
        res[rawPath] = rawFunc
    }
    {{ end }}
    return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
    var resolvePath = PathToRawSpec("")

    loader := openapi3.NewSwaggerLoader()
    loader.IsExternalRefsAllowed = true
    loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
        var pathToFile = url.String()
        if spec, ok := resolvePath[pathToFile]; !ok {
            err1 := fmt.Errorf("path not found: %s", pathToFile)
            return nil, err1
        } else {
            return spec(), nil
        }
    }
    swagger, err = loader.LoadSwaggerFromData(spec)
    if err != nil {
        return
    }
    return
}
